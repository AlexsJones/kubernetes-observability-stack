bases:
  - ../common/environments.yaml
---
repositories:
- name: helm-remote
  url: {{ .Environment.Values.helm.remote.url }}

releases:
- name: elasticsearch
  namespace: monitoring
  chart: helm-remote/elasticsearch
  version: 1.32.1
  values:
    - image:
        repository: {{ .Environment.Values.docker.proxy }}docker.elastic.co/elasticsearch/elasticsearch-oss
      initImage:
        repository: {{ .Environment.Values.docker.proxy }}busybox
      cluster:
        name: "elasticsearch"
        # If you want X-Pack installed, switch to an image that includes it, enable this option and toggle the features you want
        # enabled in the environment variables outlined in the README
        xpackEnable: false
        # Some settings must be placed in a keystore, so they need to be mounted in from a secret.
        # Use this setting to specify the name of the secret
        # keystoreSecret: eskeystore
        config: {}
        # Custom parameters, as string, to be added to ES_JAVA_OPTS environment variable
        additionalJavaOpts: ""
        # Command to run at the end of deployment
        bootstrapShellCommand: ""
        env:
          # IMPORTANT: https://www.elastic.co/guide/en/elasticsearch/reference/current/important-settings.html#minimum_master_nodes
          # To prevent data loss, it is vital to configure the discovery.zen.minimum_master_nodes setting so that each master-eligible
          # node knows the minimum number of master-eligible nodes that must be visible in order to form a cluster.
          MINIMUM_MASTER_NODES: "2"
        # List of plugins to install via dedicated init container
        plugins: []
          # - ingest-attachment
          # - mapper-size

        loggingYml:
          # you can override this using by setting a system property, for example -Des.logger.level=DEBUG
          es.logger.level: INFO
          rootLogger: ${es.logger.level}, console
          logger:
            # log action execution errors for easier debugging
            action: DEBUG
            # reduce the logging for aws, too much is logged under the default INFO
            com.amazonaws: WARN
          appender:
            console:
              type: console
              layout:
                type: consolePattern
                conversionPattern: "[%d{ISO8601}][%-5p][%-25c] %m%n"

        log4j2Properties: |
          status = error
          appender.console.type = Console
          appender.console.name = console
          appender.console.layout.type = PatternLayout
          appender.console.layout.pattern = [%d{ISO8601}][%-5p][%-25c{1.}] %marker%m%n
          rootLogger.level = info
          rootLogger.appenderRef.console.ref = console
          logger.searchguard.name = com.floragunn
          logger.searchguard.level = info
      client:
        name: client
        replicas: 2
        serviceType: ClusterIP
        ## If coupled with serviceType = "NodePort", this will set a specific nodePort to the client HTTP port
        # httpNodePort: 30920
        loadBalancerIP: {}
        loadBalancerSourceRanges: {}
      ## (dict) If specified, apply these annotations to the client service
      #  serviceAnnotations:
      #    example: client-svc-foo
        heapSize: "512m"
        # additionalJavaOpts: "-XX:MaxRAM=512m"
        antiAffinity: "soft"
        nodeAffinity: {}
        nodeSelector: {}
        tolerations: []
        # terminationGracePeriodSeconds: 60
        initResources: {}
          # limits:
          #   cpu: "25m"
          #   # memory: "128Mi"
          # requests:
          #   cpu: "25m"
          #   memory: "128Mi"
        resources:
          limits:
            cpu: "1"
            # memory: "1024Mi"
          requests:
            cpu: "25m"
            memory: "512Mi"
        priorityClassName: ""
        ## (dict) If specified, apply these annotations to each client Pod
        # podAnnotations:
        #   example: client-foo
        podDisruptionBudget:
          enabled: false
          minAvailable: 1
          # maxUnavailable: 1
        hooks: {}
          ## (string) Script to execute prior the client pod stops.
          # preStop: |-

          ## (string) Script to execute after the client pod starts.
          # postStart: |-
        ingress:
          enabled: false
          # user: NAME
          # password: PASSWORD
          annotations: {}
            # kubernetes.io/ingress.class: nginx
            # kubernetes.io/tls-acme: "true"
          path: /
          hosts:
            - chart-example.local
          tls: []
          #  - secretName: chart-example-tls
          #    hosts:
          #      - chart-example.local

      master:
        name: master
        exposeHttp: false
        replicas: 3
        heapSize: "512m"
        # additionalJavaOpts: "-XX:MaxRAM=512m"
        persistence:
          enabled: true
          accessMode: ReadWriteOnce
          name: data
          size: "4Gi"
          # storageClass: "ssd"
        readinessProbe:
          httpGet:
            path: /_cluster/health?local=true
            port: 9200
          initialDelaySeconds: 5
        antiAffinity: "soft"
        nodeAffinity: {}
        nodeSelector: {}
        tolerations: []
        # terminationGracePeriodSeconds: 60
        initResources: {}
          # limits:
          #   cpu: "25m"
          #   # memory: "128Mi"
          # requests:
          #   cpu: "25m"
          #   memory: "128Mi"
        resources:
          limits:
            cpu: "1"
            # memory: "1024Mi"
          requests:
            cpu: "25m"
            memory: "512Mi"
        priorityClassName: ""
        ## (dict) If specified, apply these annotations to each master Pod
        # podAnnotations:
        #   example: master-foo
        podManagementPolicy: OrderedReady
        podDisruptionBudget:
          enabled: false
          minAvailable: 2  # Same as `cluster.env.MINIMUM_MASTER_NODES`
          # maxUnavailable: 1
        updateStrategy:
          type: OnDelete
        hooks: {}
          ## (string) Script to execute prior the master pod stops.
          # preStop: |-

          ## (string) Script to execute after the master pod starts.
          # postStart: |-

      data:
        name: data
        exposeHttp: false
        replicas: 2
        heapSize: "1536m"
        # additionalJavaOpts: "-XX:MaxRAM=1536m"
        persistence:
          enabled: true
          accessMode: ReadWriteOnce
          name: data
          size: "30Gi"
          # storageClass: "ssd"
        readinessProbe:
          httpGet:
            path: /_cluster/health?local=true
            port: 9200
          initialDelaySeconds: 5
        terminationGracePeriodSeconds: 3600
        antiAffinity: "soft"
        nodeAffinity: {}
        nodeSelector: {}
        tolerations: []
        initResources: {}
          # limits:
          #   cpu: "25m"
          #   # memory: "128Mi"
          # requests:
          #   cpu: "25m"
          #   memory: "128Mi"
        resources:
          limits:
            cpu: "1"
            # memory: "2048Mi"
          requests:
            cpu: "25m"
            memory: "1536Mi"
        priorityClassName: ""
        ## (dict) If specified, apply these annotations to each data Pod
        # podAnnotations:
        #   example: data-foo
        podDisruptionBudget:
          enabled: false
          # minAvailable: 1
          maxUnavailable: 1
        podManagementPolicy: OrderedReady
        updateStrategy:
          type: OnDelete
        hooks:
          ## Drain the node before stopping it and re-integrate it into the cluster after start.
          ## When enabled, it supersedes `data.hooks.preStop` and `data.hooks.postStart` defined below.
          drain:
            enabled: true
